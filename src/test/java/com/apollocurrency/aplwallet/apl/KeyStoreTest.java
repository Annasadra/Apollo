/*
 * Copyright Â© 2018 Apollo Foundation
 */

package com.apollocurrency.aplwallet.apl;

import com.apollocurrency.aplwallet.apl.crypto.Crypto;
import com.apollocurrency.aplwallet.apl.util.Convert;
import com.apollocurrency.aplwallet.apl.util.JSON;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Random;

import static org.mockito.Matchers.any;
import static org.mockito.Mockito.*;

public class KeyStoreTest {
    private static final String PASSPHRASE = "random passphrase generated by passphrase generator";
    private static final String ACCOUNT1 = "APL-RRAU-CFS4-BAS5-H99KA";
    private static final String ACCOUNT2 = "APL-Y6MV-LM42-XEMB-G89UK";
    private static final String encryptedKeySeedJSON =
            "{\n" +
            "  \"encryptedKeySeed\" : \"bHUnYxIYnaVoDS8nHYMncbvWJDZUvqi4biO3qII7/ljyDAMMlniQWg7iSH87K54l+3EzOu5MXqkWQKQth0NaiQ==\",\n" +
            "  \"accountRS\" : \"APL-RRAU-CFS4-BAS5-H99KA\",\n" +
            "  \"account\" : -845296484488585958,\n" +
            "  \"size\" : 32,\n" +
            "  \"version\" : 0,\n" +
            "  \"nonce\" : \"3OFc2qfcJz4z3fi5pRHccA==\",\n" +
            "  \"timestamp\" : 1537979412861\n" +
            "}";
    private static final String KEY_SEED1 = "44a2868161a651682bdf938b16c485f359443a2c53bd3e752046edef20d11567";
    private static final String KEY_SEED2 = "146c55cbdc5f33390d207d6d08030c3dd4012c3f775ed700937a893786393dbf";
    private byte[] keySeed = generateKeySeed();
    private byte[] nonce = new byte[16];

    private byte[] generateKeySeed() {
        byte keySeed[] = new byte[32];
        Random random = new Random();
        random.nextBytes(keySeed);
        keySeed = Crypto.sha256().digest(keySeed);
        return keySeed;
    }

    private Path tempDirectory;
    private SimpleKeyStoreImpl keyStore;

    @Before
    public void setUp() throws Exception {
//        Crypto.getSecureRandom().nextBytes(nonce);
        tempDirectory = Files.createTempDirectory("keystore-test");
        keyStore = new SimpleKeyStoreImpl(tempDirectory, (byte) 0);
        Files.write(tempDirectory.resolve("---" + ACCOUNT1), encryptedKeySeedJSON.getBytes());
    }

    @After
    public void tearDown() throws Exception {
        Files.list(tempDirectory).forEach(tempFilePath -> {
            try {
                Files.delete(tempFilePath);
            }
            catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
        Files.delete(tempDirectory);
    }

    @Test
    public void testSaveKeySeed() throws Exception {
        SimpleKeyStoreImpl keyStoreSpy = spy(keyStore);

        keyStoreSpy.saveKeySeed(PASSPHRASE, Convert.parseHexString(KEY_SEED2));

        verify(keyStoreSpy, times(1)).storeJSONKeySeed(any(Path.class), any(EncryptedKeySeedDetails.class));
        verify(keyStoreSpy, times(1)).findKeySeedPaths(anyLong());

        Assert.assertEquals(2, Files.list(tempDirectory).count());

        String rsAcc = Convert.rsAccount(Convert.getId(Crypto.getPublicKey(Convert.parseHexString(KEY_SEED2))));

        Path encryptedKeyPath =
                Files.list(tempDirectory).filter(path -> path.getFileName().toString().endsWith(rsAcc)).findFirst().orElseThrow(()->new RuntimeException("No encrypted key found for " + rsAcc  + " account"));

        EncryptedKeySeedDetails keySeedDetails = JSON.getMapper().readValue(encryptedKeyPath.toFile(), EncryptedKeySeedDetails.class);

        byte[] actualKeySeed = Crypto.aesDecrypt(keySeedDetails.getEncryptedKeySeed(), Crypto.getKeySeed(PASSPHRASE,
                keySeedDetails.getNonce(), Convert.longToBytes(keySeedDetails.getTimestamp())));

        Assert.assertEquals(KEY_SEED2, Convert.toHexString(actualKeySeed));
    }


    @Test
    public void testGetKeySeed() throws Exception {


        SimpleKeyStoreImpl keyStoreSpy = spy(keyStore);

        long accountId = Convert.parseAccountId(ACCOUNT1);
        byte[] actualKeySeed = keyStoreSpy.getKeySeed(PASSPHRASE, accountId);
        String rsAcc = Convert.rsAccount(accountId);

        verify(keyStoreSpy, times(1)).verifyExistOnlyOne(any(List.class), eq(accountId));
        verify(keyStoreSpy, times(1)).findKeySeedPaths(accountId);

        Assert.assertEquals(1, Files.list(tempDirectory).count());
        Path encryptedKeyPath = Files.list(tempDirectory).findFirst().get();
        Assert.assertTrue(encryptedKeyPath.getFileName().toString().endsWith(rsAcc));

        Assert.assertEquals(KEY_SEED1, Convert.toHexString(actualKeySeed));

    }
    @Test(expected = SecurityException.class)
    public void testGetKeySeedUsingIncorrectPassphrase() throws Exception {
        long accountId = Convert.parseAccountId(ACCOUNT1);
        keyStore.getKeySeed("pass", accountId);

    }
    @Test(expected = RuntimeException.class)
    public void testGetKeySeedUsingIncorrectAccount() throws Exception {
        long accountId = 0;
        keyStore.getKeySeed(PASSPHRASE, accountId);
    }

    @Test(expected = RuntimeException.class)
    public void testSaveDuplicateKeySeed() throws IOException {
        keyStore.saveKeySeed(PASSPHRASE, Convert.parseHexString(KEY_SEED1));
    }


}

