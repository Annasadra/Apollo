/*
 * Copyright Â© 2018 Apollo Foundation
 */

package com.apollocurrency.aplwallet.apl;

import com.apollocurrency.aplwallet.apl.crypto.Crypto;
import com.apollocurrency.aplwallet.apl.util.Convert;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Random;

import static org.mockito.Matchers.any;
import static org.mockito.Mockito.*;

public class KeyStoreTest {
    private static final String PASSPHRASE = "random passphrase generated by passphrase generator";
    private static final String ACCOUNT = "APL-3A2F-4U5Q-FCWY-7UUHH";
    private static final String encryptedKeySeedJSON = "{\"bytes\":32,\"accountRS\":\"APL-3A2F-4U5Q-FCWY-7UUHH\",\"encryptedKeySeed\":\"fd242aad99bac6f78bb549abc1750a60715996259ba89ee1fc9a41b4c5ae5dc4597e60a4e0d00e4929fdc37ec74146704da6545a0c4584fa7daa3c9ce0efbb08\",\"nonce\":\"9ee8d8259db831f2012cbc8406ac3e8f\",\"account\":6322871454658502669}";
    private static final String KEY_SEED = "5e32f9120e45519251bb68efe19ed1ed50deeee164270ed8d4816daff37c560a";




    private byte[] keySeed = generateKeySeed();
    private byte[] nonce = new byte[16];
    private JSONParser jsonParser = new JSONParser();

    private byte[] generateKeySeed() {
        byte keySeed[] = new byte[32];
        Random random = new Random();
        random.nextBytes(keySeed);
        keySeed = Crypto.sha256().digest(keySeed);
        return keySeed;
    }

    private Path tempDirectory;
    private SimpleKeyStoreImpl keyStore;

    @Before
    public void setUp() throws Exception {
        Crypto.getSecureRandom().nextBytes(nonce);
        tempDirectory = Files.createTempDirectory("keystore-test");
        keyStore = new SimpleKeyStoreImpl(tempDirectory, (byte) 0);
        Files.write(tempDirectory.resolve("---" + ACCOUNT), encryptedKeySeedJSON.getBytes());
    }

    @After
    public void tearDown() throws Exception {
        Files.list(tempDirectory).forEach(tempFilePath -> {
            try {
                Files.delete(tempFilePath);
            }
            catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
        Files.delete(tempDirectory);
    }

    @Test
    public void testSaveKeySeed() throws Exception {
        SimpleKeyStoreImpl keyStoreSpy = spy(keyStore);

        keyStoreSpy.saveKeySeed(PASSPHRASE, keySeed);

        verify(keyStoreSpy, times(1)).storeJSONKeySeed(any(Path.class), any(JSONObject.class));
        verify(keyStoreSpy, times(1)).getJSONObject(anyLong(), any(byte[].class), anyInt(), any(byte[].class));
        verify(keyStoreSpy, times(1)).findKeySeedPaths(anyLong());

        Assert.assertEquals(2, Files.list(tempDirectory).count());

        String rsAcc = Convert.rsAccount(Convert.getId(Crypto.getPublicKey(keySeed)));
        Path encryptedKeyPath =
                Files.list(tempDirectory).filter(path -> path.getFileName().toString().endsWith(rsAcc)).findFirst().orElseThrow(()->new RuntimeException("No encrypted key found for " + rsAcc  + " account"));

        byte[] bytes = Files.readAllBytes(encryptedKeyPath);

        JSONObject json = (JSONObject) jsonParser.parse(new String(bytes));
        String encryptedKeySeed = (String) json.get("encryptedKeySeed");
        String nonce = (String) json.get("nonce");
        byte[] actualKeySeed = Crypto.aesDecrypt(Convert.parseHexString(encryptedKeySeed), Crypto.getKeySeed(PASSPHRASE,
                Convert.parseHexString(nonce)));

        Assert.assertArrayEquals(keySeed, actualKeySeed);
    }


    @Test
    public void testGetKeySeed() throws Exception {


        SimpleKeyStoreImpl keyStoreSpy = spy(keyStore);

        long accountId = Convert.parseAccountId(ACCOUNT);
        byte[] actualKeySeed = keyStoreSpy.getKeySeed(PASSPHRASE, accountId);
        String rsAcc = Convert.rsAccount(accountId);

        verify(keyStoreSpy, times(1)).verify(any(List.class), eq(accountId));
        verify(keyStoreSpy, times(1)).findKeySeedPaths(accountId);
        verify(keyStoreSpy, times(2)).readBytes(any(JSONObject.class), anyString());
        Assert.assertEquals(1, Files.list(tempDirectory).count());
        Path encryptedKeyPath = Files.list(tempDirectory).findFirst().get();
        Assert.assertTrue(encryptedKeyPath.getFileName().toString().endsWith(rsAcc));

        Assert.assertEquals(KEY_SEED, Convert.toHexString(actualKeySeed));

    }
    @Test(expected = SecurityException.class)
    public void testGetKeySeedUsingIncorrectPassphrase() throws Exception {
        long accountId = Convert.parseAccountId(ACCOUNT);
        keyStore.getKeySeed("pass", accountId);

    }
    @Test(expected = RuntimeException.class)
    public void testGetKeySeedIncorrectAccount() throws Exception {
        long accountId = 0;
        keyStore.getKeySeed(PASSPHRASE, accountId);
    }

    @Test(expected = RuntimeException.class)
    public void testSaveDuplicateKeySeed() throws IOException {
        keyStore.saveKeySeed(PASSPHRASE, Convert.parseHexString(KEY_SEED));
    }


}

